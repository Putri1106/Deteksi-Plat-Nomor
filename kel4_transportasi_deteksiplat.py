# -*- coding: utf-8 -*-
"""Kel4-Transportasi-DeteksiPlat

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wgKOxaccsTgJxUT5eKHC80hiPubP-tVN
"""

!pip install roboflow # Menginstal pustaka Roboflow untuk manajemen dataset dan model computer vision.

!pip install pytesseract # Menginstal pustaka Python untuk mengakses Tesseract OCR.
!sudo apt install tesseract-ocr # Menginstal aplikasi Tesseract OCR di sistem berbasis Linux.

# Mengimpor library yang diperlukan
import os  # Untuk bekerja dengan file dan direktori
import glob  # Untuk pencarian file dengan pola tertentu
from roboflow import Roboflow  # Untuk mengunduh dataset dari Roboflow
from PIL import Image  # Untuk manipulasi gambar
import cv2  # Untuk membaca dan memproses gambar
import numpy as np  # Untuk manipulasi array dan data numerik
import matplotlib.pyplot as plt  # Untuk visualisasi data
import pandas as pd  # Untuk manipulasi data tabular
import pytesseract  # Untuk Optical Character Recognition (OCR)

# Inisialisasi roboflow untuk mengunduh dataset baru
rf = Roboflow(api_key="rNTIZ0w8wQufXvTb9bXp")  # Menggunakan API key Roboflow
project = rf.workspace("parkets").project("anpr-test-py7gr")  # Akses proyek di Roboflow
version = project.version(2)  # Memilih versi dataset
dataset = version.download("yolov11")  # Mengunduh dataset ke lokasi lokal

# Menampilkan lokasi direktori dataset yang diunduh
print(f"Dataset lokasi diunduh: {dataset.location}")

# Menentukan direktori gambar yang ada di dalam dataset
img_dir = dataset.location

# Menentukan ukuran gambar yang akan diproses
IMAGE_SIZE = 224  # Ukuran gambar diubah menjadi 224x224 piksel

# Mencari semua gambar dengan ekstensi .jpg, .png, .jpeg
files = []
for dirname, _, filenames in os.walk(img_dir):  # Melintasi direktori dataset
    for filename in filenames:
        if filename.endswith(('.jpg', '.jpeg', '.png')):  # Mengecek ekstensi file gambar
            files.append(os.path.join(dirname, filename))  # Menyimpan path gambar

# Menampilkan jumlah gambar yang ditemukan
print(f"Jumlah file gambar yang ditemukan: {len(files)}")
print(f"Beberapa file gambar yang ditemukan: {files[:5]}")  # Menampilkan 5 file pertama

# Membaca dan mengubah ukuran gambar
X = []  # Array untuk menyimpan gambar yang sudah diproses
for f1 in files:
    img = cv2.imread(f1)  # Membaca gambar menggunakan OpenCV
    if img is not None:  # Memastikan gambar berhasil dibaca
        img = cv2.resize(img, (IMAGE_SIZE, IMAGE_SIZE))  # Mengubah ukuran gambar
        X.append(np.array(img))  # Menambahkan gambar ke array dataset
    else:
        print(f"Warning: Unable to read image at {f1}")  # Peringatan jika gagal membaca gambar

# Verifikasi ukuran dataset setelah gambar dimuat
print(f"Jumlah gambar yang berhasil dimuat: {len(X)}")
print(f"Dimensi dataset (jumlah gambar, tinggi, lebar, saluran): {np.array(X).shape}")

# Untuk menghubungkan Google Drive ke Google Colab
from google.colab import drive
drive.mount('/content/drive')

# Menentukan jumlah gambar yang ingin ditampilkan dan ukuran grid
num_images = len(X)  # Jumlah total gambar yang berhasil dimuat
rows = 12  # Jumlah baris pada grid
cols = 10  # Jumlah kolom pada grid

# Menampilkan semua gambar yang berhasil dimuat
plt.figure(figsize=(20, 20))  # Mengatur ukuran tampilan grid (20x20 inci)
for i in range(0, num_images):
    if i + 1 > rows * cols:  # Memeriksa apakah jumlah gambar melebihi kapasitas grid
        print(f"Warning: Skipping image {i + 1} as it exceeds the grid size.")  # Pesan peringatan
        break  # Menghentikan loop jika grid penuh
    plt.subplot(rows, cols, i + 1)  # Membuat subplot untuk setiap gambar
    plt.axis('off')  # Menyembunyikan sumbu subplot
    plt.imshow(X[i])  # Menampilkan gambar dari array X
plt.show()  # Menampilkan seluruh gambar di grid

# Menentukan path direktori tempat gambar disimpan
image_path = "/content/ANPR-test-2/valid/images"  # Lokasi folder yang berisi gambar

# Inisialisasi array untuk menyimpan gambar yang dimuat
X = []  # Array kosong untuk menampung gambar yang diubah menjadi array NumPy

# Melintasi semua file gambar dalam direktori
for img_file in os.listdir(image_path):  # Menggunakan os.listdir untuk membaca semua file di dalam folder
    img = Image.open(os.path.join(image_path, img_file))  # Membuka file gambar menggunakan Pillow (PIL)
    X.append(np.array(img))  # Mengonversi gambar ke dalam bentuk array NumPy dan menambahkannya ke array X

# Menampilkan jumlah gambar yang berhasil dimuat
print(f"Jumlah gambar yang dimuat: {len(X)}")  # Menampilkan jumlah gambar dalam array X

image_dir = "/content/DatasetPlatNomor/valid/images" #Dua variabel string menyimpan jalur direktori untuk gambar (image_dir) dan label (label_dir)
label_dir = "/content/DatasetPlatNomor/valid/labels"

image_files = os.listdir(image_dir) #Fungsi os.listdir(image_dir) digunakan untuk mendapatkan daftar nama semua file di dalam direktori gambar (image_dir). Variabel image_files sekarang berisi nama-nama file seperti "image1.jpg", "image2.jpg", dll.
for image_file in image_files: #Loop for iterasi melalui setiap nama file di dalam image_files
    label_file = os.path.join(label_dir, image_file.replace('.jpg', '.txt')) #Nama file label dihitung dengan mengganti ekstensi file gambar .jpg menjadi .txt menggunakan replace('.jpg', '.txt')
    if os.path.exists(label_file): #Fungsi os.path.exists(label_file) memeriksa apakah file label yang dihasilkan (label_file) ada di direktori label_dir
        print(f"Label ditemukan untuk {image_file}") #Jika file label ditemukan, mencetak pesan seperti "Label ditemukan untuk image1.jpg"
    else:
        print(f"Label tidak ditemukan untuk {image_file}") #Jika file label tidak ditemukan, mencetak pesan seperti "Label tidak ditemukan untuk image2.jpg"

def read_yolo_label(label_path): #Fungsi ini mengambil argumen label_path, yaitu jalur file label YOLO
    boxes = [] #Variabel boxes adalah list kosong yang digunakan untuk menyimpan informasi bounding box yang ditemukan
    with open(label_path, 'r') as file: #File label di jalur label_path dibuka dalam mode baca ('r')
        for line in file: #Iterasi membaca setiap baris dalam file.
            data = line.strip().split() #Fungsi strip() menghapus karakter spasi atau newline (\n) di awal/akhir baris
            if len(data) == 5: #Baris valid dalam file YOLO harus memiliki 5 elemen, Jika baris tidak memenuhi syarat ini, fungsi akan mengabaikannya tanpa menambahkan ke list
                class_id, center_x, center_y, width, height = map(float, data) #Fungsi map(float, data) mengonversi setiap elemen data ke tipe data float
                boxes.append((class_id, center_x, center_y, width, height)) #Tuple (class_id, center_x, center_y, width, height) ditambahkan ke list boxes
    return boxes #Fungsi mengembalikan seluruh daftar bounding box yang sudah dikumpulkan.

def yolo_to_bbox(image, bbox):
    h, w, _ = image.shape  #h adalah tinggi objek, w adalah lebar objek,_ adalah jumlah kanal, image.shape= mengembalikan (tinggi, lebar, jumlah_channel).
    center_x, center_y, box_width, box_height = bbox  # Koordinat pusat bounding box . Lebar dan tinggi bounding box
    x_min = int((center_x - box_width / 2) * w)  #Kode ini menghitung koordinat x kiri atas bounding box dari pusat dan lebarnya.
    y_min = int((center_y - box_height / 2) * h)  #Kode ini menghitung y teratas dari kotak berdasarkan pusat dan tinggi gambar.
    x_max = int((center_x + box_width / 2) * w)  #Kode ini menghitung x terjauh (kanan) dari kotak berdasarkan pusat dan lebar gambar.
    y_max = int((center_y + box_height / 2) * h)  #Kode ini menghitung y terbawah dari kotak berdasarkan pusat dan tinggi gambar.
    return (x_min, y_min, x_max, y_max)  #mengembalikan hasil perhitungan bounding bo dalam format koordinat absolut

for image_file in image_files:  #Kode ini berarti melakukan perulangan untuk setiap file dalam daftar `image_files`.
    image_path = os.path.join(image_dir, image_file)  #Kode ini menggabungkan folder dan nama file untuk membentuk path lengkap gambar.
    label_path = os.path.join(label_dir, image_file.replace('.jpg', '.txt')) #Membuat path file label dengan mengganti ekstensi `.jpg` pada nama file gambar menjadi `.txt` lalu menggabungkannya dengan folder label.

    if not os.path.exists(label_path):#Pernyataan ini memeriksa apakah path yang ada di variabel `label_path` tidak ada di sistem file, dan menjalankan kode jika path tersebut tidak ditemukan.
        print(f"Label tidak ditemukan untuk {image_file}") #Ini akan mencetak pesan yang memberitahukan bahwa label untuk file gambar yang disebutkan tidak ditemukan.
        continue #Melanjutkan ke iterasi berikutnya, melewati proses gambar tersebut tanpa error

    print(f"Label ditemukan untuk {image_file}") #Mencetak pesan yang menampilkan bahwa label telah ditemukan untuk file gambar tertentu.

    image = cv2.imread(image_path) #digunakan untuk membaca gambar dari file yang terletak di path yang diberikan (image_path) dan menyimpannya ke dalam variabel image.
    if image is None:  #Memeriksa apakah variabel image kosong atau tidak berisi objek gambar.
        print(f"Gambar {image_file} tidak dapat dibaca.") #Menampilkan pesan kesalahan yang memberitahukan bahwa gambar yang disebutkan dalam variabel image_file tidak bisa dibaca.
        continue  #Melanjutkan ke iterasi berikutnya, melewati proses gambar tersebut tanpa error

    labels = read_yolo_label(label_path) #Membaca file label YOLO dari path yang ada pada variabel label_path dan menyimpannya dalam variabel labels.

    for label in labels: #Melakukan iterasi atau perulangan pada setiap elemen yang ada dalam list atau koleksi labels.
        class_id, center_x, center_y, width, height = label  #Membagi nilai dari label ke dalam variabel class_id, center_x, center_y, width, dan height untuk menyimpan informasi tentang objek dalam gambar.
        bbox_coords = yolo_to_bbox(image, (center_x, center_y, width, height)) #Pernyataan ini mengonversi koordinat bounding box dalam format YOLO (pusat dan ukuran) ke dalam format koordinat kotak pembatas pada gambar.
        cv2.rectangle(image, (bbox_coords[0], bbox_coords[1]), (bbox_coords[2], bbox_coords[3]), (0, 255, 0), 2) #Menggambar persegi panjang pada gambar menggunakan koordinat bbox_coords, dengan warna hijau (0, 255, 0) dan ketebalan garis 2 piksel.
        cv2.putText(image, str(int(class_id)), (bbox_coords[0], bbox_coords[1] - 10),  #menambahkan teks yang berisi class_id pada gambar di posisi sedikit di atas koordinat awal bounding box.
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 2)  #Menambahkan teks di gambar dengan font "HERSHEY_SIMPLEX", ukuran 0.5, warna merah, dan ketebalan garis 2.

    plt.figure(figsize=(8, 8)) #Membuat sebuah figure baru dengan ukuran lebar dan tinggi 8 inci pada plot menggunakan Matplotlib.
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))  #Mengubah format warna gambar dari BGR ke RGB dan menampilkannya menggunakan plt.imshow.
    plt.axis('off')  #Menyembunyikan axis (garis pengukur) pada gambar
    plt.title(f"Gambar {image_file} dengan Bounding Box")  #Memberikan judul pada gambar yang akan ditampilkan
    plt.show() #Menampilkan grafik atau plot yang telah dibuat dengan Matplotlib di jendela visualisasi.

def validate_bbox(image, bbox):  #Memeriksa apakah bounding box (bbox) valid dan berada dalam area gambar (image).
    """Pastikan bounding box berada dalam dimensi gambar."""
    h, w, _ = image.shape #h adalah tinggi objek, w adalah lebar objek,_ adalah jumlah kanal, image.shape= mengembalikan (tinggi, lebar, jumlah_channel).
    x_min, y_min, x_max, y_max = bbox #Membagi nilai bounding box bbox menjadi empat variabel: x_min, y_min, x_max, dan y_max yang mewakili koordinat batas.
    x_min = max(0, x_min)  #Memastikan bahwa nilai x_min tidak kurang dari 0, sehingga jika x_min lebih kecil dari 0, nilainya akan diubah menjadi 0.
    y_min = max(0, y_min)  #Memastikan bahwa nilai y_min tidak akan kurang dari 0, menggantinya dengan 0 jika nilainya lebih kecil dari 0.
    x_max = min(w, x_max)  #Menetapkan nilai x_max sebagai nilai terkecil antara w dan x_max.
    y_max = min(h, y_max)  #mengatur nilai y_max menjadi nilai terkecil antara h dan y_max, sehingga y_max tidak akan melebihi h.
    return (x_min, y_min, x_max, y_max)  #Mengembalikan nilai berupa tuple yang berisi koordinat batas minimum dan maksimum pada sumbu x dan y.

def yolo_to_bbox(image, yolo_coords):
    """Mengonversi koordinat YOLO menjadi bounding box."""
    h, w, _ = image.shape  # Ambil dimensi gambar
    center_x, center_y, width, height = yolo_coords  # Ambil koordinat YOLO
    x_min = int((center_x - width / 2) * w)  # Hitung x_min absolut
    y_min = int((center_y - height / 2) * h)  # Hitung y_min absolut
    x_max = int((center_x + width / 2) * w)  # Hitung x_max absolut
    y_max = int((center_y + height / 2) * h)  # Hitung y_max absolut
    return (x_min, y_min, x_max, y_max)  # Kembalikan koordinat bounding box

def validate_bbox(image, bbox):
    """Pastikan bounding box berada dalam dimensi gambar."""
    h, w, _ = image.shape  # Ambil dimensi gambar
    x_min, y_min, x_max, y_max = bbox  # Pisahkan koordinat bounding box
    x_min = max(0, x_min)  # Pastikan x_min >= 0. koordinat horizontal paling kiri
    y_min = max(0, y_min)  # Pastikan y_min >= 0. koordinat vertikal paling atas
    x_max = min(w, x_max)  # Pastikan x_max <= lebar gambar. koordinat horizontal paling kanan
    y_max = min(h, y_max)  # Pastikan y_max <= tinggi gambar. koordinat horizontal paling bawah
    return (x_min, y_min, x_max, y_max)  # Kembalikan bounding box yang tervalidasi

def preprocess_image(image):
    """Melakukan preprocessing pada gambar sebelum OCR."""
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  # Konversi gambar ke grayscale
    return cv2.threshold(gray_image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]  #line ini mengonversi gambar grayscale menjadi gambar biner (hitam-putih)
    #THRESH_BINARY : Piksel di atas threshold diubah menjadi putih (255), dan di bawah threshold menjadi hitam (0), 255 adalah nilai maksimum yang diberikan pada piksel yang memenuhi kriteria threshold.
    #THRES_OTSU : Menentukan threshold secara otomatis berdasarkan distribusi intensitas piksel pada gambar.
def extract_plate_number(image, bbox, debug_dir, image_file, bbox_index):
    """Menggunakan OCR untuk mengekstrak teks dari area bounding box."""
    bbox = validate_bbox(image, bbox)  # Validasi bounding box
    x_min, y_min, x_max, y_max = bbox  # Pisahkan koordinat bounding box
    cropped_image = image[y_min:y_max, x_min:x_max]  # Potong gambar sesuai bounding box

    if cropped_image.size == 0:  # Cek apakah hasil crop kosong
        return "Bounding Box Kosong"

    debug_crop_path = os.path.join(debug_dir, f"cropped_{image_file}_{bbox_index}.jpg")  # Path untuk hasil debug
    cv2.imwrite(debug_crop_path, cropped_image)  # Simpan hasil crop untuk debugging

    preprocessed_image = preprocess_image(cropped_image)  # Lakukan preprocessing
    try:
        # Gunakan OCR untuk membaca teks dari gambar
        plate_number = pytesseract.image_to_string(preprocessed_image, config='--psm 7 -c tessedit_char_whitelist=0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ') #psm7 untuk mengonsumsikan gambar hanya memiliki satu baris teks dan cocok untuk mendeteksi plat nomor
        print(f"OCR Result for {image_file}, BBox {bbox_index}: {plate_number.strip()}")  # Debugging hasil OCR
        return plate_number.strip()  # Kembalikan hasil OCR
    except Exception as e:
        print(f"Error OCR pada bounding box: {e}")  # Tangkap kesalahan OCR
        return "OCR Error"

# Direktori dataset
image_dir = '/content/ANPR-test-2/valid/images'  # Folder gambar input
label_dir = '/content/ANPR-test-2/valid/labels'  # Folder label YOLO
debug_dir = './debug_crops'  # Folder untuk hasil debug

os.makedirs(debug_dir, exist_ok=True)  # Buat folder debug jika belum ada

image_files = [f for f in os.listdir(image_dir) if f.endswith('.jpg')]  # Ambil semua file gambar .jpg
results = []  # List untuk menyimpan hasil

for image_file in image_files:  # Loop untuk setiap file gambar
    image_path = os.path.join(image_dir, image_file)  # Path gambar
    label_path = os.path.join(label_dir, image_file.replace('.jpg', '.txt'))  # Path label

    if not os.path.exists(label_path):  # Jika label tidak ditemukan
        print(f"Label tidak ditemukan untuk {image_file}")  # Pesan error
        continue

    print(f"Memproses {image_file}")  # Debugging proses

    image = cv2.imread(image_path)  # Baca gambar
    if image is None:  # Jika gambar gagal dibaca
        print(f"Gambar {image_file} tidak dapat dibaca.")  # Pesan error
        continue

    labels = read_yolo_label(label_path)  # Baca file label YOLO
    for bbox_index, label in enumerate(labels):  # Loop setiap label
        class_id, center_x, center_y, width, height = label  # Pisahkan label
        bbox_coords = yolo_to_bbox(image, (center_x, center_y, width, height))  # Konversi YOLO ke bbox
        plate_number = extract_plate_number(image, bbox_coords, debug_dir, image_file, bbox_index)  # Ekstraksi nomor plat

        results.append({  # Tambahkan hasil ke dalam list
            'File Gambar': image_file,
            'ID Kelas': class_id,
            'Tengah X': center_x,
            'Tengah Y': center_y,
            'Lebar': width,
            'Tinggi': height,
            'X_min': bbox_coords[0],
            'Y_min': bbox_coords[1],
            'X_max': bbox_coords[2],
            'Y_max': bbox_coords[3],
            'Nomor Plat': plate_number
        })

df = pd.DataFrame(results)  # Buat DataFrame dari hasil
output_excel_path = "output_plate_numbers.xlsx"  # Path untuk file output
df.to_excel(output_excel_path, index=False, engine='openpyxl')  # Simpan DataFrame ke Excel

print(f"Hasil telah disimpan ke {output_excel_path}")  # Debugging output
print(f"Hasil crop disimpan di folder {debug_dir}")  # Debugging hasil crop